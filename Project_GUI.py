import tkinter as tk
from tkinter import filedialog
from tkinter import messagebox
import re
import subprocess



#function to get all the strings in the maware sample and store them in a file(output_file)
def get_all_strings(input_file, output_file):

    # Define the full path to the strings executable
    strings_executable = r"C:\Users\Public\SysinternalsSuite\strings.exe"
    command = [strings_executable, input_file]
    
    try:
        # Open the output file in write mode
        with open(output_file, 'w') as output:
            # Run the command and capture the output
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
            
            # Read the output line by line and write to the output file
            for line in process.stdout:
                output.write(line)
            
            # Wait for the process to complete
            stdout, stderr = process.communicate()
            if process.returncode != 0:
                raise Exception(f"Error: {stderr}")
    except FileNotFoundError:
        print(f"The file {strings_executable} was not found. Please check the path.")
    except Exception as e:
        print(f"An error occurred: {e}")


# Function to extract interesting strings from a .txt file
def extract_strings(file_path, min_length=4):
    with open(file_path, 'r', encoding='utf-8') as f:
        data = f.read()
    # Extract strings of at least min_length
    pattern = re.compile(r'[\x20-\x7E]{' + str(min_length) + ',}')
    extracted_strings = pattern.findall(data)
    print(f"Extracted {len(extracted_strings)} strings from the file.")
    return extracted_strings


# Function to classify strings based on predefined patterns
def classify_strings(strings):
    classifications = {
        "urls": [],
        "api_calls": [],
        "file_paths": [],
        "registry_keys": []
    }

    # Define simple patterns for classification
    url_pattern = re.compile(r'https?://[^\s]+')
    api_pattern = re.compile(r'\b\w*File\w*\b|\b\w*Key\w*\b|\bCreate\w*\b|\bRemote\w*\b|\bVirtual\w*\b')
    file_path_pattern = re.compile(r'[A-Za-z]:\\[^\n\r]*')
    registry_pattern = re.compile(r'HK[LMCU]\\\\[^\s]+')

    for string in strings:
        if url_pattern.search(string):
            classifications["urls"].append(string)
        if api_pattern.search(string):
            classifications["api_calls"].append(string)
        if file_path_pattern.search(string):
            classifications["file_paths"].append(string)
        if registry_pattern.search(string):
            classifications["registry_keys"].append(string)

    #print(f"Classified strings: {classifications}")
    return classifications

# Function to determine if strings are suspicious
def is_suspicious(string, category):
    suspicious_criteria = {
        "urls": [
            # Match URLs with specific suspicious patterns, such as long paths, unusual TLDs, and query parameters
            re.compile(r'https?://(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(?:/[a-zA-Z0-9-._~:/?#\[\]@!$&\'()*+,;%=]*){2,}'),
            re.compile(r'https?://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?:/[a-zA-Z0-9-._~:/?#\[\]@!$&\'()*+,;%=]*){1,}')
        ],
        "api_calls": [
            # Exact matches for known suspicious API calls with word boundaries
            re.compile(r'\bCreateRemoteThread\b'),
            re.compile(r'\bVirtualAllocEx\b')
        ],
        "file_paths": [
            # More specific file paths typically associated with suspicious activity
            re.compile(r'\\Temp\\[a-zA-Z0-9_\-]+\.exe$'),
            re.compile(r'\\AppData\\Roaming\\[a-zA-Z0-9_\-]+\\[a-zA-Z0-9_\-]+\.exe$'),
            re.compile(r'\\AppData\\Local\\[a-zA-Z0-9_\-]+\\[a-zA-Z0-9_\-]+\.exe$')
        ],
        "registry_keys": [
            # Exact registry keys commonly associated with malware persistence
            re.compile(r'HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\[a-zA-Z0-9_\-]+'),
            re.compile(r'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\[a-zA-Z0-9_\-]+')
        ]
    }
    
    for criterion in suspicious_criteria.get(category, []):
        if criterion.search(string):
            print(f"Suspicious {category[:-1]} found: {string}")
            return True
    return False

def getHash(path):
    result = subprocess.run(['CertUtil', '-hashfile', path, 'MD5'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, shell=True)
    output = result.stdout
    #print(output.splitlines()[1])
    return output.splitlines()[1]



# Function to generate the report
def generate_report():

    
    file_path = file_entry.get()
    hash = getHash(file_path)

    #file contains all the strings in the sample
    all_strings_path = r"C:\Users\Public\output.txt"
    get_all_strings(file_path ,all_strings_path)

    # Extract the interesting strings from the file
    extracted_strings = extract_strings(all_strings_path)

    # Classify the extracted strings
    classified_strings = classify_strings(extracted_strings)

    # Analyze and flag suspicious strings
    suspicious_strings = {
        "urls": [],
        "api_calls": [],
        "file_paths": [],
        "registry_keys": []
    }

    for category, strings in classified_strings.items():
        for string in strings:
            if is_suspicious(string, category):
                suspicious_strings[category].append(string)

    # Generate report
    report = f"String Analysis and Classification:\n \n Hash of the sample {hash}\n \n "
    for category, strings in classified_strings.items():
        report += f"\n{category.replace('_', ' ').capitalize()}:\n"
        for string in strings:
            suspicion = " (Suspicious)" if string in suspicious_strings[category] else ""
            report += f"- {string}{suspicion}\n"

    #print(report)

    try:
        report_text.delete('1.0', tk.END)
        report_text.insert(tk.END, report)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to open file: {e}")

# Function to open file dialog
def browse_file():
    file_path = filedialog.askopenfilename()
    file_entry.delete(0, tk.END)
    file_entry.insert(0, file_path)




##############################################################################################################################
###################################################  GUI   ###################################################################
##############################################################################################################################

# Create the main window
root = tk.Tk()
root.title("File Report Generator")

# Create and place the file entry widget
file_entry = tk.Entry(root, width=50)
file_entry.pack(pady=10)

# Create and place the browse button
browse_button = tk.Button(root, text="Browse", command=browse_file)
browse_button.pack(pady=5)

# Create and place the generate report button
generate_button = tk.Button(root, text="Generate Report", command=generate_report)
generate_button.pack(pady=10)

# Create and place the text widget to display the report
report_text = tk.Text(root, wrap='word', height=20, width=80)
report_text.pack(pady=10)

# Run the application
root.mainloop()
